<img src="../../assets/icon.png" width="100" height="100" />

# @repo/database

The `@repo/database` package is the **single source of truth for the entire database schema and core
database utilities** within the Tunno monorepo. It leverages
[`Drizzle ORM`](https://orm.drizzle.team/) to define a type-safe and relational schema, and provides
helpers for common database operations, including pagination and robust error handling.

---

## About

This package centralizes all database-related definitions and functionalities, ensuring consistency
and type safety across all applications interacting with the data layer. It defines:

- **Database Schema**: A comprehensive definition of all tables (e.g., `songs`, `albums`, `artists`,
  `playlists`, `sidebar`, `playHistory`) and their relationships using Drizzle ORM. This includes
  column definitions, data types, constraints, and indexes.
- **Type Definitions**: Automatically generated TypeScript types (via Drizzle's `$inferSelect` and
  `$inferInsert`) for each entity, providing strong typing for data selection and insertion
  operations.
- **Query Helpers**: Utility functions for building complex queries, such as keyset pagination with
  multi-column sorting (`buildCursorCondition`, `getOrderByFromColumn`).
- **Error Handling Utilities**: A set of type guards and helper functions (`isConstraintError`,
  `extractConstraintInfo`) designed to identify and parse specific SQLite constraint errors,
  enabling more precise error management and user feedback.

By providing these foundational elements, `@repo/database` enables other packages (like `@repo/api`)
and applications to interact with the database in a consistent, type-safe, and efficient manner.

---

## Installation

This is an internal package within the Tunno monorepo and is not intended for external installation.
It is automatically available to other packages and applications within the monorepo via
`pnpm workspace`.

---

## Usage

The `@repo/database` package is typically consumed by other internal packages (e.g., `@repo/api`)
and applications to define the database client, interact with the schema, and utilize helper
functions.

### Database Schema and Types

The schema is exported as a namespace `schema`, allowing direct access to table definitions and
relationships. Entity types are also exported for type-safe operations.

```typescript
import { schema, type Album, type InsertAlbum } from "@repo/database"
// Assume 'database' is your Drizzle client instance, typically set up in the application layer.

// Accessing a table definition
const albumsTable = schema.albums

// Using inferred types
const myAlbum: Album = {
  id: 1,
  uuid: "some-uuid",
  name: "My Awesome Album",
  releaseYear: 2023
  // ... other fields
}

const newAlbum: InsertAlbum = {
  name: "Another Album",
  albumType: "album"
  // uuid will be generated by default
}

// Example: Inserting a new album (assuming 'database' is available in scope)
async function createAlbum(albumData: InsertAlbum) {
  // await database.insert(schema.albums).values(albumData);
  // Actual database interaction would happen here.
}
```

### Query Helpers (Pagination)

The `buildCursorCondition` and `getOrderByFromColumn` helpers are essential for implementing
efficient keyset pagination.

```typescript
import {
  buildCursorCondition,
  getOrderByFromColumn,
  type CursorValue,
  schema
} from "@repo/database"
// Assume 'database' is your Drizzle client instance.
import { asc, desc, and } from "drizzle-orm"

async function getPaginatedSongs(
  limit: number,
  cursor?: string, // base64 encoded cursor
  orderByColumn: "name" | "createdAt" = "createdAt",
  orderDirection: "asc" | "desc" = "desc"
) {
  const cursorValues: CursorValue[] = cursor ? JSON.parse(atob(cursor)) : []

  const orderBy = getOrderByFromColumn(schema.songs[orderByColumn], orderDirection)

  const cursorCondition = buildCursorCondition({
    cursorValues,
    columns: [schema.songs[orderByColumn], schema.songs.id],
    direction: orderDirection,
    tiebreakerDirection: "asc" // Assuming ID is always ascending for tie-breaking
  })

  const songs = await database.query.songs.findMany({
    limit: limit + 1, // Fetch one extra item to check for next page
    where: cursorCondition ? and(cursorCondition) : undefined,
    orderBy: [orderBy, asc(schema.songs.id)] // Always tie-break by ID
  })

  const hasNextPage = songs.length > limit
  const items = hasNextPage ? songs.slice(0, limit) : songs

  // Logic to encode next and prev cursors (omitted for brevity)
  const nextCursor = hasNextPage
    ? btoa(JSON.stringify([items[items.length - 1][orderByColumn], items[items.length - 1].id]))
    : undefined

  return { items, hasNextPage, nextCursor }
}
```

### Error Handling

The package provides utilities to identify and extract information from Drizzle/SQLite constraint
errors.

```typescript
import {
  isUniqueConstraintError,
  extractConstraintInfo,
  ValidationErrorCode // From @repo/api, example usage
} from "@repo/database" // isUniqueConstraintError is from @repo/database, ValidationErrorCode is from @repo/api

// In an error handling context
try {
  // Some database operation that might cause an error
  // await database.insert(schema.artists).values({ name: 'Existing Artist' });
} catch (error) {
  if (isUniqueConstraintError(error)) {
    const errorInfo = extractConstraintInfo(error)
    console.error(
      `Unique constraint violation: ${errorInfo?.table}.${errorInfo?.column} - ${errorInfo?.message}`
    )
    // You can map this to a CustomError from @repo/api if needed
    // throw new CustomError(ValidationErrorCode.DUPLICATE_ARTIST, errorInfo?.column || 'name', 'Artist already exists', 'artist');
  } else {
    console.error("An unexpected database error occurred:", error)
  }
}
```

---

## API Reference

### Exports

- **`schema`**: A namespace containing all Drizzle ORM table definitions and their relations (e.g.,
  `schema.albums`, `schema.songsRelations`).
- **`helpers`**:
  - `buildCursorCondition`: Function to construct SQL `WHERE` clauses for keyset pagination.
  - `getOrderByFromColumn`: Function to generate Drizzle `asc` or `desc` order expressions.
  - `isConstraintError`, `isUniqueConstraintError`, `isNotNullConstraintError`,
    `isForeignKeyConstraintError`: Type guards for various SQLite constraint errors.
  - `extractConstraintInfo`: Function to parse detailed information (table, column, type) from
    constraint errors.
- **Types**:
  - `Album`, `InsertAlbum`: Types for selecting and inserting album data.
  - `Artist`, `InsertArtist`: Types for selecting and inserting artist data.
  - `Playlist`, `InsertPlaylist`: Types for selecting and inserting playlist data.
  - `Song`, `InsertSong`: Types for selecting and inserting song data.
  - `Sidebar`, `InsertSidebar`: Types for selecting and inserting sidebar data.
  - `InferQueryModel`: Advanced type utility for inferring Drizzle query result models with
    relations.
  - `CursorValue`, `ConstraintErrorInfo`, `DatabaseError`.

---

## Dependencies

This package depends on:

- [`drizzle-orm`](https://orm.drizzle.team/): The primary ORM for database interactions.
- [`uuid`](https://www.npmjs.com/package/uuid): Used for generating unique identifiers (UUIDs) for
  entities.

---

## License

This project is licensed under the MIT License. See the [LICENSE](../../LICENSE) file for details.
